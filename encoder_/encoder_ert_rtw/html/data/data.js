var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"encoder","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"encoder.h\"                   /* Model header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(encoder_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  encoder_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example main function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific. This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  encoder_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.01 seconds (base rate of the model) here.\r\n   * The call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(encoder_M) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Terminate model */\r\n  encoder_terminate();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"encoder.c","type":"source","group":"model","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: encoder.c\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"encoder.h\"\r\n#include \"rotaryEncoder.h\"\r\n#include \"encoder_types.h\"\r\n#include \"encoder_private.h\"\r\n\r\n/* Block states (default storage) */\r\nDW_encoder_T encoder_DW;\r\n\r\n/* Previous zero-crossings (trigger) states */\r\nPrevZCX_encoder_T encoder_PrevZCX;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_encoder_T encoder_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_encoder_T encoder_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_encoder_T encoder_M_;\r\nRT_MODEL_encoder_T *const encoder_M = &encoder_M_;\r\n\r\n/* Model step function */\r\nvoid encoder_step(void)\r\n{\r\n  /* Outputs for Atomic SubSystem: '<Root>/rotaryEncoder' */\r\n\r\n  /* Outport: '<Root>/counter_U16' incorporates:\r\n   *  Inport: '<Root>/encOutA_B'\r\n   *  Inport: '<Root>/encOutB_B'\r\n   *  Outport: '<Root>/s_direction_E'\r\n   */\r\n  encoder_rotaryEncoder(encoder_U.encOutA_B, encoder_U.encOutB_B,\r\n                        &encoder_Y.counter_U16, &encoder_Y.s_direction_E,\r\n                        &encoder_DW.rotaryEncoder,\r\n                        &encoder_PrevZCX.rotaryEncoder);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/rotaryEncoder' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid encoder_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* external outputs */\r\n  encoder_Y.s_direction_E = CLOCKWISE_ROTATION;\r\n  encoder_PrevZCX.rotaryEncoder.Delay_Reset_ZCE = POS_ZCSIG;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid encoder_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"encoder.h","type":"header","group":"model","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: encoder.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_encoder_h_\r\n#define RTW_HEADER_encoder_h_\r\n#ifndef encoder_COMMON_INCLUDES_\r\n#define encoder_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* encoder_COMMON_INCLUDES_ */\r\n\r\n#include \"encoder_types.h\"\r\n#include \"rotaryEncoder.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  DW_rotaryEncoder_encoder_T rotaryEncoder;/* '<Root>/rotaryEncoder' */\r\n} DW_encoder_T;\r\n\r\n/* Zero-crossing (trigger) state */\r\ntypedef struct {\r\n  ZCE_rotaryEncoder_encoder_T rotaryEncoder;/* '<Root>/rotaryEncoder' */\r\n} PrevZCX_encoder_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  boolean_T encOutA_B;                 /* '<Root>/encOutA_B' */\r\n  boolean_T encOutB_B;                 /* '<Root>/encOutB_B' */\r\n} ExtU_encoder_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  uint16_T counter_U16;                /* '<Root>/counter_U16' */\r\n  ROTATION_DIRECTION_E s_direction_E;  /* '<Root>/s_direction_E' */\r\n} ExtY_encoder_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_encoder_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block states (default storage) */\r\nextern DW_encoder_T encoder_DW;\r\n\r\n/* Zero-crossing (trigger) state */\r\nextern PrevZCX_encoder_T encoder_PrevZCX;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_encoder_T encoder_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_encoder_T encoder_Y;\r\n\r\n/* Model entry point functions */\r\nextern void encoder_initialize(void);\r\nextern void encoder_step(void);\r\nextern void encoder_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_encoder_T *const encoder_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'encoder'\r\n * '<S1>'   : 'encoder/rotaryEncoder'\r\n * '<S2>'   : 'encoder/rotaryEncoder/Compare To Constant'\r\n * '<S3>'   : 'encoder/rotaryEncoder/Compare To Constant1'\r\n * '<S4>'   : 'encoder/rotaryEncoder/Switch Case Action Subsystem'\r\n * '<S5>'   : 'encoder/rotaryEncoder/Switch Case Action Subsystem1'\r\n * '<S6>'   : 'encoder/rotaryEncoder/Switch Case Action Subsystem2'\r\n * '<S7>'   : 'encoder/rotaryEncoder/defineDirection'\r\n * '<S8>'   : 'encoder/rotaryEncoder/defineDirection/Detect Decrease'\r\n * '<S9>'   : 'encoder/rotaryEncoder/defineDirection/Detect Decrease1'\r\n * '<S10>'  : 'encoder/rotaryEncoder/defineDirection/Enumerated Constant'\r\n * '<S11>'  : 'encoder/rotaryEncoder/defineDirection/Enumerated Constant1'\r\n * '<S12>'  : 'encoder/rotaryEncoder/defineDirection/Enumerated Constant2'\r\n */\r\n#endif                                 /* RTW_HEADER_encoder_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"encoder_private.h","type":"header","group":"model","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: encoder_private.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_encoder_private_h_\r\n#define RTW_HEADER_encoder_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"encoder_types.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n#endif                                 /* RTW_HEADER_encoder_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"encoder_types.h","type":"header","group":"model","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: encoder_types.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_encoder_types_h_\r\n#define RTW_HEADER_encoder_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef DEFINED_TYPEDEF_FOR_ROTATION_DIRECTION_E_\r\n#define DEFINED_TYPEDEF_FOR_ROTATION_DIRECTION_E_\r\n\r\ntypedef enum {\r\n  CLOCKWISE_ROTATION = 1,              /* Default value */\r\n  ANTI_CLOCKWISE_ROTATION = 2,\r\n  NO_ROTATION = 0\r\n} ROTATION_DIRECTION_E;\r\n\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_encoder_T RT_MODEL_encoder_T;\r\n\r\n#endif                                 /* RTW_HEADER_encoder_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rotaryEncoder.c","type":"source","group":"subsystem","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * File: rotaryEncoder.c\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"encoder_types.h\"\r\n#include \"rotaryEncoder.h\"\r\n#include \"encoder_private.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Output and update for atomic system: '<Root>/rotaryEncoder' */\r\nvoid encoder_rotaryEncoder(boolean_T rtu_encOutA_B, boolean_T rtu_encOutB_B,\r\n  uint16_T *rty_counter_U16, ROTATION_DIRECTION_E *rty_s_direction_E,\r\n  DW_rotaryEncoder_encoder_T *localDW, ZCE_rotaryEncoder_encoder_T *localZCE)\r\n{\r\n  boolean_T rtb_OR;\r\n\r\n  /* Logic: '<S1>/OR' incorporates:\r\n   *  Constant: '<S2>/Constant'\r\n   *  Delay: '<S1>/Delay1'\r\n   *  RelationalOperator: '<S2>/Compare'\r\n   */\r\n  rtb_OR = (localDW->Delay1_DSTATE > 20);\r\n\r\n  /* Delay: '<S1>/Delay' */\r\n  if (rtb_OR && (localZCE->Delay_Reset_ZCE != POS_ZCSIG)) {\r\n    localDW->Delay_DSTATE = 0U;\r\n  }\r\n\r\n  localZCE->Delay_Reset_ZCE = rtb_OR;\r\n\r\n  /* Switch: '<S7>/Switch' incorporates:\r\n   *  Constant: '<S10>/Constant'\r\n   *  Constant: '<S12>/Constant'\r\n   *  Logic: '<S7>/AND'\r\n   *  Logic: '<S7>/AND1'\r\n   *  RelationalOperator: '<S8>/FixPt Relational Operator'\r\n   *  RelationalOperator: '<S9>/FixPt Relational Operator'\r\n   *  Switch: '<S7>/Switch1'\r\n   *  UnitDelay: '<S8>/Delay Input1'\r\n   *  UnitDelay: '<S9>/Delay Input1'\r\n   *\r\n   * Block description for '<S8>/Delay Input1':\r\n   *\r\n   *  Store in Global RAM\r\n   *\r\n   * Block description for '<S9>/Delay Input1':\r\n   *\r\n   *  Store in Global RAM\r\n   */\r\n  if (((int32_T)rtu_encOutA_B < (int32_T)localDW->DelayInput1_DSTATE) &&\r\n      rtu_encOutB_B) {\r\n    *rty_s_direction_E = CLOCKWISE_ROTATION;\r\n  } else if (rtu_encOutA_B && ((int32_T)rtu_encOutB_B < (int32_T)\r\n              localDW->DelayInput1_DSTATE_h)) {\r\n    /* Switch: '<S7>/Switch1' incorporates:\r\n     *  Constant: '<S11>/Constant'\r\n     */\r\n    *rty_s_direction_E = ANTI_CLOCKWISE_ROTATION;\r\n  } else {\r\n    *rty_s_direction_E = NO_ROTATION;\r\n  }\r\n\r\n  /* End of Switch: '<S7>/Switch' */\r\n\r\n  /* SwitchCase: '<S1>/Switch Case' */\r\n  switch (*rty_s_direction_E) {\r\n   case CLOCKWISE_ROTATION:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem' incorporates:\r\n     *  ActionPort: '<S4>/Action Port'\r\n     */\r\n    /* DataTypeConversion: '<S4>/Data Type Conversion' incorporates:\r\n     *  Constant: '<S4>/Constant'\r\n     *  Delay: '<S1>/Delay'\r\n     *  Sum: '<S4>/Add'\r\n     */\r\n    *rty_counter_U16 = (uint16_T)(((localDW->Delay_DSTATE + 1) >> 1) << 1);\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem' */\r\n    break;\r\n\r\n   case ANTI_CLOCKWISE_ROTATION:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S5>/Action Port'\r\n     */\r\n    /* DataTypeConversion: '<S5>/Data Type Conversion' incorporates:\r\n     *  Constant: '<S5>/Constant'\r\n     *  Delay: '<S1>/Delay'\r\n     *  Sum: '<S5>/Add'\r\n     */\r\n    *rty_counter_U16 = (uint16_T)((uint16_T)((localDW->Delay_DSTATE - 1) >> 1) <<\r\n      1);\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem1' */\r\n    break;\r\n\r\n   default:\r\n    /* Outputs for IfAction SubSystem: '<S1>/Switch Case Action Subsystem2' incorporates:\r\n     *  ActionPort: '<S6>/Action Port'\r\n     */\r\n    /* SignalConversion generated from: '<S6>/prevCounterVal_U16' incorporates:\r\n     *  Delay: '<S1>/Delay'\r\n     */\r\n    *rty_counter_U16 = localDW->Delay_DSTATE;\r\n\r\n    /* End of Outputs for SubSystem: '<S1>/Switch Case Action Subsystem2' */\r\n    break;\r\n  }\r\n\r\n  /* End of SwitchCase: '<S1>/Switch Case' */\r\n\r\n  /* Update for Delay: '<S1>/Delay1' */\r\n  localDW->Delay1_DSTATE = *rty_counter_U16;\r\n\r\n  /* Update for Delay: '<S1>/Delay' */\r\n  localDW->Delay_DSTATE = *rty_counter_U16;\r\n\r\n  /* Update for UnitDelay: '<S8>/Delay Input1'\r\n   *\r\n   * Block description for '<S8>/Delay Input1':\r\n   *\r\n   *  Store in Global RAM\r\n   */\r\n  localDW->DelayInput1_DSTATE = rtu_encOutA_B;\r\n\r\n  /* Update for UnitDelay: '<S9>/Delay Input1'\r\n   *\r\n   * Block description for '<S9>/Delay Input1':\r\n   *\r\n   *  Store in Global RAM\r\n   */\r\n  localDW->DelayInput1_DSTATE_h = rtu_encOutB_B;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rotaryEncoder.h","type":"header","group":"subsystem","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"/*\r\n * File: rotaryEncoder.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rotaryEncoder_h_\r\n#define RTW_HEADER_rotaryEncoder_h_\r\n#ifndef encoder_COMMON_INCLUDES_\r\n#define encoder_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* encoder_COMMON_INCLUDES_ */\r\n\r\n#include \"encoder_types.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Block states (default storage) for system '<Root>/rotaryEncoder' */\r\ntypedef struct {\r\n  uint16_T Delay1_DSTATE;              /* '<S1>/Delay1' */\r\n  uint16_T Delay_DSTATE;               /* '<S1>/Delay' */\r\n  boolean_T DelayInput1_DSTATE;        /* '<S8>/Delay Input1' */\r\n  boolean_T DelayInput1_DSTATE_h;      /* '<S9>/Delay Input1' */\r\n} DW_rotaryEncoder_encoder_T;\r\n\r\n/* Zero-crossing (trigger) state for system '<Root>/rotaryEncoder' */\r\ntypedef struct {\r\n  ZCSigState Delay_Reset_ZCE;          /* '<S1>/Delay' */\r\n} ZCE_rotaryEncoder_encoder_T;\r\n\r\nextern void encoder_rotaryEncoder(boolean_T rtu_encOutA_B, boolean_T\r\n  rtu_encOutB_B, uint16_T *rty_counter_U16, ROTATION_DIRECTION_E\r\n  *rty_s_direction_E, DW_rotaryEncoder_encoder_T *localDW,\r\n  ZCE_rotaryEncoder_encoder_T *localZCE);\r\n\r\n#endif                                 /* RTW_HEADER_rotaryEncoder_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Intel->x86-64 (Windows64)\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"D:\\mahmodzidancourse\\encoder_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: zero_crossing_types.h\r\n *\r\n * Code generated for Simulink model 'encoder'.\r\n *\r\n * Model version                  : 1.1\r\n * Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n * C/C++ source code generated on : Tue Jul 16 00:29:25 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"cm":{"GlobalVarInfo":[{"Name":"encoder.c:encoder_M_","Size":8,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":true,"IsBitField":false,"IsExported":true,"UseCount":0,"Members":{"Name":"errorStatus","File":2,"Size":8,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":0,"Members":[],"UseInFunctions":[]},"UseInFunctions":[]},{"Name":"encoder_DW","Size":6,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":false,"IsBitField":false,"IsExported":true,"UseCount":1,"Members":{"Name":"rotaryEncoder","File":2,"Size":6,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[{"Name":"Delay1_DSTATE","File":5,"Size":2,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"Delay_DSTATE","File":5,"Size":2,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"DelayInput1_DSTATE","File":5,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"DelayInput1_DSTATE_h","File":5,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}}],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"encoder_PrevZCX","Size":1,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":false,"IsBitField":false,"IsExported":true,"UseCount":2,"Members":{"Name":"rotaryEncoder","File":2,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":2,"Members":{"Name":"Delay_Reset_ZCE","File":5,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":2,"Members":[],"UseInFunctions":[{"FunctionName":"encoder_step","UseCount":1},{"FunctionName":"encoder_initialize","UseCount":1}]},"UseInFunctions":[{"FunctionName":"encoder_step","UseCount":1},{"FunctionName":"encoder_initialize","UseCount":1}]},"UseInFunctions":[{"FunctionName":"encoder_step","UseCount":1},{"FunctionName":"encoder_initialize","UseCount":1}]},{"Name":"encoder_U","Size":2,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":false,"IsBitField":false,"IsExported":true,"UseCount":2,"Members":[{"Name":"encOutA_B","File":2,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"encOutB_B","File":2,"Size":1,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}}],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":2}},{"Name":"encoder_Y","Size":8,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":false,"IsBitField":false,"IsExported":true,"UseCount":3,"Members":[{"Name":"counter_U16","File":2,"Size":2,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":1,"Members":[],"UseInFunctions":{"FunctionName":"encoder_step","UseCount":1}},{"Name":"s_direction_E","File":2,"Size":4,"IsStatic":false,"IsBitField":false,"IsExported":false,"UseCount":2,"Members":[],"UseInFunctions":[{"FunctionName":"encoder_step","UseCount":1},{"FunctionName":"encoder_initialize","UseCount":1}]}],"UseInFunctions":[{"FunctionName":"encoder_step","UseCount":2},{"FunctionName":"encoder_initialize","UseCount":1}]}],"GlobalConstInfo":[],"FcnInfo":[{"Name":"encoder_initialize","UniqueKey":"$encoder_initialize","Idx":1,"NumCommentLines":2,"NumTotalLines":8,"NumCodeLines":2,"Callee":[],"Caller":[],"Stack":0,"HasDefinition":1,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":0,"Complexity":1,"StackTotal":0,"CalleeIdx":[]},{"Name":"encoder_rotaryEncoder","UniqueKey":"$encoder_rotaryEncoder","Idx":2,"NumCommentLines":70,"NumTotalLines":122,"NumCodeLines":31,"Callee":[],"Caller":{"Name":"encoder_step","Weight":1},"Stack":35,"HasDefinition":1,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\rotaryEncoder.c"],"IsStatic":0,"Complexity":6,"StackTotal":35,"CalleeIdx":[]},{"Name":"encoder_step","UniqueKey":"$encoder_step","Idx":3,"NumCommentLines":7,"NumTotalLines":16,"NumCodeLines":4,"Callee":{"Name":"encoder_rotaryEncoder","Weight":1},"Caller":[],"Stack":0,"HasDefinition":1,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":0,"Complexity":1,"StackTotal":35,"CalleeIdx":2},{"Name":"encoder_terminate","UniqueKey":"$encoder_terminate","Idx":4,"NumCommentLines":1,"NumTotalLines":4,"NumCodeLines":0,"Callee":[],"Caller":[],"Stack":0,"HasDefinition":1,"File":["D:\\mahmodzidancourse\\encoder_ert_rtw\\encoder.c"],"IsStatic":0,"Complexity":1,"StackTotal":0,"CalleeIdx":[]}]},"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};